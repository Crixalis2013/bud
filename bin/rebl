#!/usr/bin/env ruby
require 'readline'
require 'rubygems'
require 'bud'
require 'abbrev'

TABLE_TYPES = ["table", "scratch"]
BUILTIN_TABLES = [:stdio, :t_depends, :periodics_tbl, :t_cycle, :localtick,
                  :t_provides, :t_rules, :t_depends_tc, :t_stratum]
HISTFILE = "~/.rebl_history"
MAXHISTSIZE = 100

# set up everything
class ReblClass
  include Bud
  attr_accessor :commands
  
  @@escape_char = '/'
  def self.escape_char; @@escape_char; end

  @@commands = {"tick" => ["@rebl_class_inst.tick", ReblClass::escape_char+"tick: 	execute a timestep"],
               "lsrules" =>["@rules.each{|k,v| puts k.to_s + ':  ' + v}", ReblClass::escape_char+"lsrules: 	list rules"],
               "rmrule" => ["@rules.delete(Integer(split_line[1]));reinstantiate", ReblClass::escape_char+"rmrule x: 	remove rule number x"], 
               "lscollections" => ["puts @rebl_class_inst.tables.keys.find_all{ |tn| not BUILTIN_TABLES.include? tn}.inspect", ReblClass::escape_char+"lscollections: 	list collections"],
               "dump" => ['@rebl_class_inst.instance_eval("#{split_line[1]}.dump")', ReblClass::escape_char+"dump c: 	dump contents of collection c"],
               "exit" => ["ReblClass::do_exit", ReblClass::escape_char+"exit: 	exit rebl"],
               "quit" => ["ReblClass::do_exit", ReblClass::escape_char+"quit: 	exit rebl"],
               "help" => ["ReblClass::pretty_help", ReblClass::escape_char+"help: 	print this help message"] }

	@@abbrevs = @@commands.keys.abbrev
  @@exit_message = "Rebellion quashed."
   
  def self.commands; @@commands; end
  
  def self.command(c)
    return @@abbrevs[c].nil? ? nil : @@commands[@@abbrevs[c]][0]
  end            
  
  def self.pretty_help
	  puts "rebl commands are prefixed by '#{ReblClass::escape_char}'"
	  puts "other input is interpreted as Bloom code."
	  puts
	  puts "rebl commands:"
    maxlen = @@commands.keys.sort{|a,b| b.size - a.size}.first.size
    @@commands.values.each do |v|
      puts v[1].gsub( /\t/, " "*(maxlen + 3 - v[1].split(':')[0].size))
    end
  end
  
  def self.welcome
	  puts "Welcome to rebl, the interactive Bloom terminal."
		puts
		puts "Type: " + ReblClass::escape_char + "h for help"
		puts "      " + ReblClass::escape_char + "q to quit"
		puts
	end
	
  def self.do_exit
    puts "\n" + @@exit_message
    exit!
  end
end

def reinstantiate
  # new anonymous subclass
  @rebl_class = Class.new(ReblClass)

	begin
	  if not @rules.empty?
	    @rebl_class.class_eval("bloom :rebl_rules do\n" +
	                           @rules.sort.map {|_,r| r}.join("\n") + "\nend")
	  end
	rescue
		raise
	end

	begin
	  if not @state.empty?
	    @rebl_class.class_eval("state do\n" + @state.values.join("\n") + "\nend")
	  end
	rescue 
		raise
	end
	
  # instantiate it
  @old_inst = @rebl_class_inst
  @rebl_class_inst = @rebl_class.new

  # copy the tables over
  if @old_inst
    @rebl_class_inst.tables.merge!(@old_inst.tables.reject do |k,v|
                                     BUILTIN_TABLES.include? k
                                   end)
  end
end

def setup_history
  # permament history; code lifted from irb
  begin
    histfile = File::expand_path(HISTFILE)
    if File::exists?(histfile)
      lines = IO::readlines(histfile).collect { |line| line.chomp }
      Readline::HISTORY.push(*lines)
    end
    Kernel::at_exit do
      lines = Readline::HISTORY.to_a.reverse.uniq.reverse
      lines = lines[-MAXHISTSIZE, MAXHISTSIZE] if lines.nitems > MAXHISTSIZE
      File::open(histfile, File::WRONLY|File::CREAT|File::TRUNC) { |io| io.puts lines.join("\n") }
    end
  rescue Exception
    puts "Error when configuring permanent history: #{$!}"
  end
end

# main
@rules = {}
@ruleid = 0
@state = {}
@stateid = 0
@new_table = nil
reinstantiate
setup_history

comp = proc { |s| ReblClass::commands.keys.map{|c| ReblClass::escape_char+c}.grep( /^#{Regexp.escape(s)}/ ) }

Readline.completion_append_character = ' '
Readline.completion_proc = comp

ReblClass.welcome

loop do
  begin
    line = Readline::readline('rebl> ')
		ReblClass::do_exit if line.nil?
		line = line.lstrip.rstrip
    Readline::HISTORY.push(line)
    split_line = line.split(" ")

    # command
    if line[0..0] == ReblClass::escape_char then
      split_line[0].slice! 0
      if ReblClass::command split_line[0]
        eval ReblClass::command split_line[0]
      else
        puts "invalid command or ambiguous command prefix"
      end
      next
    end

    # collection
    if TABLE_TYPES.include? split_line[0]
      @state[@stateid += 1] = line
      begin
        reinstantiate
      rescue Exception
        @state.delete(@stateid)
        raise
      end
    else # assume it's a rule
      @rules[@ruleid += 1] = line
      begin
        reinstantiate
      rescue Exception
        @rules.delete(@ruleid)
        raise
      end
    end
    next

  rescue Interrupt
    abort(ReblClass::do_exit)
  rescue Exception
    puts "exception: #{$!}"
  end
end
