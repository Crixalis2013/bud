# Bud Cheat Sheet #

## General Bud Syntax Rules ##
Bud programs are sets of unordered statements, embedded in Ruby.<br>
Statements are delimited by semicolons (;) or newlines. <br>
As in Ruby, backslash is used to escape a newline.<br>

## Bud Statements ##
*lhs BudOp rhs*

Left-hand-side (lhs) is a named BudCollection object.<br>
Right-hand-side (rhs) is a Ruby expression producing a BudCollection or Array of Arrays.<br>
BudOp is one of the 5 Bud Operators below.

## Bud Operators ##
merges:

* `left <= right` &nbsp;&nbsp;&nbsp;&nbsp; (*instantaneous*)
* `left <+ right` &nbsp;&nbsp;&nbsp;&nbsp; (*deferred*)
* `left <~ right` &nbsp;&nbsp;&nbsp;&nbsp; (*asynchronous*)

insert:

* `left << [...]` &nbsp;&nbsp;&nbsp;&nbsp; (*instantaneous*)

delete:

* `left <- right` &nbsp;&nbsp;&nbsp;&nbsp; (*deferred*)

operators can be chained.  for example:

* `chan <= tab <= right` &nbsp;&nbsp;&nbsp;&nbsp;   (*store and forward*)
* `left <- (chan <~ right)`&nbsp;&nbsp;&nbsp; (*async delete*)

## State Declarations ##
### Typical Form ###
*BudCollection :name, [keys] => [values]*

### table ###
contents persist in memory until deleted.<br>
default attributes: `[:key] => [:val]`

    table :keyvalue
    table :composite, [:keyfield1, :keyfield2] => [:values]
    table :dupsIgnored, [:field1, field2]

### scratch ###
contents emptied at start of each timestep<br>
default attributes: `[:key] => [:val]`

    scratch :stats

### interface ###
scratch collections, used as module interfaces<br>
default attributes: `[:key] => [:val]`

    interface input, :request
    interface output, :response

### channel ###
network channel manifested as a scratch collection.  <br>
address attribute prefixed with `@`.  <br>
default attributes: `[:@address, :val] => []`

Statements with channel on lhs must use async merge (`<~`).


    channel :msgs      
    channel :req_chan, [:@address, :cartnum, :storenum] => [:command, :params]


### periodic ###
system timer manifested as a scratch collection.<br>
given attributes: `[:key] => [:val]`<br>
&nbsp;&nbsp;&nbsp;&nbsp; key is a unique ID, val is a Ruby Time converted to a string.<br>
state declaration includes interval (in seconds)

periodic can only be used on rhs of statement

    periodic :timer, 0.1
    
### stdio ###
built-in scratch collection mapped to Ruby's STDIN and STDOUT<br>
given attributes: `[:line] => []`

statements with stdio on lhs must use async merge (`<~`)<br>
to capture STDIN on rhs, instantiate Bud with `:read_stdin` option.<br>

### tctable ###
table collection mapped to a [Tokyo Cabinet](http://fallabs.com/tokyocabinet/) store.<br>
default attributes: `[:key] => [:val]`

    tctable :t1
    tctable :t2, [:k1, :k2] => [:v1, :v2]
    

### zktable ###
table collection mapped to an [Apache Zookeeper](http://hadoop.apache.org/zookeeper/) store.<br>
given attributes: `[:key] => [:val]`<br>
state declaration includes zookeeper path
and optional TCP string (default: "localhost:2181")<br>

    zktable :foo, "/bat"
    zktable :bar, "/dat", "localhost:2182"


## Collection Methods ##
Standard Ruby methods used on a BudCollection `bc`:

`map`:

    t1 <= bc.map{|t| [t.col1 + 4, t.col2.chomp]} # formatting/projection
    t2 <= bc.map{|t| t if t.col = 5}             # selection

`flat_map`:

    require 'backports' # flat_map not included in Ruby 1.8 by default
    
    t3 <= bc.flat_map do |t| # unnest a collection-valued attribute
      bc.col4.map { |sub| [t.col1, t.col2, t.col3, sub] }
    end

`bc.reduce`, `bc.inject`: 

    t4 <= bc.reduce({}) do |memo, t|  # example: groupby col1 and count
      memo[t.col1] ||= 0
      memo[t.col1] += 1
      memo
    end
   

`bc.include?`:

    t5 <= bc.map do |t| # like SQL's NOT IN
        t unless t2.include?([t.col1, t.col2])
    end 

## BudCollection-Specific Methods ##
`bc.keys`: projects `bc` to key columns<br>

`bc.values`: projects `bc` to non-key columns<br>

`bc.inspected`: shorthand for `bc.map{|t| [t.inspect]}`, to merge into stdio

`chan.payloads`: shorthand for chan.map{|t| t.val}, only defined for channels, to unpack nested vals

## SQL-style grouping/aggregation (and then some) ##

* `bc.group([:col1, :col2], min(:col3))`.  *akin to min(col3) GROUP BY (col1,col2)*
  * exemplary aggs: `min`, `max`, `choose`
  * summary aggs: `sum`, `avg`, `count`
  * structural aggs: `accum`
* `bc.argmax([:col1], :col2)` &nbsp;&nbsp;&nbsp;&nbsp; *returns the bc tuple per col1 that has highest col2*
* `bc.argmin([:col1], :col2)`

## Built-in Aggregates: ##

* Exemplary aggs: `min`, `max`, `choose`
* Summary aggs: `count`, `sum`, `avg`
* Structural aggs: `accum`

## Relational Operators ###

* `join([:t1, :t2], [t1.col1, t2.col2])`
* `natjoin`
* `leftjoin`
* `outerjoin`

## Interacting with Bud from Ruby ##
* `run`
* `run_bg`
* `sync_do`
* `async_do`
* `BudCollection.dump`

## Bud Code Visualizer ##



## Skeleton of a Bud Module ##

    require 'rubygems'
    require 'bud'

    module YourModule
      include BudModule
  
      state {
        ...
      }
  
      def bootstrap
        ...
      end
  
      declare 
      def SomeBudStmts
         ...
      end

      declare
      def MoreBudStmts
        ...
      end
    end

