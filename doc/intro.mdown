# Welcome to *Bud*: Bloom in Ruby #
Thanks for stopping by!

Bud is a Ruby-based prototype of the [*Bloom*](http://bloom.cs.berkeley.edu) language for distributed programming.  "Bud" stands for *Bloom under development*, and it's just that: an early prototype of Bloom.  

## Blooming Distributed Code ##
The goal of Bloom is to make distributed programming far easier than it has been traditionally.  The key features of Bloom are:

1. *Disorderly Programming*:  Unlike most languages, Bloom makes no assumptions about order of operations. Instead, you write "disorderly" programs: unordered collections of statements on unordered collections of data.   Distributed systems don't respect the order of operations; why code them as if they do?

2. *A Collected Approach*: The standard data structures in Bloom are disorderly collections, rather than scalar variables and structures.  Bloom provides simple, familiar syntax for manipulating the state of your program.  In the Bud prototype, much of this syntax comes straight from Ruby (with a taste of MapReduce and SQL).

3. *CALM Consistency*: Bloom enables powerful compiler analysis techniques based on the [CALM principle](http://db.cs.berkeley.edu/papers/cidr11-bloom.pdf) to reason about the consistency of your distributed code.  Bud includes program analysis tools that can point out precise *points of order* in your program: lines of code where a coordination library should be plugged in to ensure distributed consistency.

4. *Concise Code*: Bloom is a very high-level language, designed with distributed code in mind.  As a result, Bloom programs tend to be far smaller (often [orders of magnitude](http://boom.cs.berkeley.edu) smaller) than equivalent programs in traditional imperative languages.


## Friends and Family: Come On In ##
Bloom is beginning life as a research project, but our goal is to enable real developers to get real work done.  Faster.  Better.  In a more maintainable and malleable way.

To get to that point, we're offering Bud as a pre-alpha "friends and family" edition of Bloom.  This is definitely the bleeding edge: we're in a rapid  cycle of learning about this new style of programming, and exposing what we learn in new iterations of the language.  If you'd like to jump on the wheel with us and play with Bud, we'd love your feedback -- both success stories and constructive criticism.

## Getting Started ##
We're shipping Bud with a suite of libraries and example applications for distributed systems.  These both illustrate the language and how it can be used, and can serve as mixins for new code you might want to write.  You may be surprised at how short the provided Bud code is, but don't be fooled.

To help newcomers learn the language, we've provided an annotated *cheat sheet* to overview the language, a *tutorial* that walks through some of the provided examples, and a simple *language reference*.  Like Bud itself, these documents are an early alpha, and we welcome both constructive criticism and the (hopefully occasional) smoke-out-your-ears, hair-tearing shouts of frustration.

We also provide instructions and tools for launching Bud code on Amazon's EC2 cloud, and instrumenting what it's doing up there.
